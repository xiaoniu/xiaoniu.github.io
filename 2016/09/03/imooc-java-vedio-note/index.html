<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  




<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Android,Java," />








  <link rel="shortcut icon" type="image/x-icon" href="/images/favico.png?v=5.0.1" />






<meta name="description" content="开学就要大四了，校招也要开始了。想想自己的能力，感觉差了太多太多，暑假都不敢出去玩，想着多花点时间复习总结一下以前的知识，找工作时能用的到。
Java是我大一时自学的，现在会写但是很多没用到的概念全给忘了，于是就想复习一下。因为我已经有了一定的基础知识，所以这个笔记并不是一个详尽的Java笔记，而只是记录我所遗忘或需要加强记忆的部分。

基础发展历史  1995年sun公司推出Java语言，200">
<meta property="og:type" content="article">
<meta property="og:title" content="再看Java--imooc三季Java视频笔记">
<meta property="og:url" content="http://yoursite.com/2016/09/03/imooc-java-vedio-note/index.html">
<meta property="og:site_name" content="小牛的博客">
<meta property="og:description" content="开学就要大四了，校招也要开始了。想想自己的能力，感觉差了太多太多，暑假都不敢出去玩，想着多花点时间复习总结一下以前的知识，找工作时能用的到。
Java是我大一时自学的，现在会写但是很多没用到的概念全给忘了，于是就想复习一下。因为我已经有了一定的基础知识，所以这个笔记并不是一个详尽的Java笔记，而只是记录我所遗忘或需要加强记忆的部分。

基础发展历史  1995年sun公司推出Java语言，200">
<meta property="og:image" content="http://img.mukewang.com/53689f74000187be03800330.jpg">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1849253-75fba879962153ee.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1849253-18d186c6a34c13e0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1849253-a76821117741a454.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1849253-e3e620a80c3c1f9a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1849253-d29011d32a54c773.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1849253-dd2addc410aa1b1d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1849253-6dd540304075b70a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1849253-b236f1e6f6ba397b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1849253-45e8dc811a559db1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1849253-91440ad609a91a6c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1849253-f2d8e31eb3c31c23.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1849253-9f33adaa26c93b03.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1849253-37f0bf7c69924d55.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1849253-6d64f752ee7f8277.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1849253-c17257f0a26d3e27.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1849253-8301fb3d963097a6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1849253-1bb4d5da49650029.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1849253-135d1ea15f328ba2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1849253-55c0b7a83b773ad6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1849253-e15199e52e35054f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1849253-542be2a4dee87d26.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1849253-f3b883f2dbf537b4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1849253-fa854885dff36fd7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1849253-58c44869a4d8c83b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1849253-1ff6668d7fd1c2a5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1849253-01c92908887d385f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1849253-92c4a5f7601fc3bf.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1849253-3a8148ed5a3248fa.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1849253-c193c299d13ac86d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1849253-57ebf0ee4cb74f5f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1849253-57af602db717420a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1849253-9118fd10a965a7ea.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1849253-37ec0caa028093fc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1849253-c1a25318d26fcdc8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1849253-2e9845eb4bb04f8a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1849253-0b611466346ff542.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1849253-f5f843c8d9be8edf.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1849253-1074e693ab073338.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2016-09-03T08:59:10.964Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="再看Java--imooc三季Java视频笔记">
<meta name="twitter:description" content="开学就要大四了，校招也要开始了。想想自己的能力，感觉差了太多太多，暑假都不敢出去玩，想着多花点时间复习总结一下以前的知识，找工作时能用的到。
Java是我大一时自学的，现在会写但是很多没用到的概念全给忘了，于是就想复习一下。因为我已经有了一定的基础知识，所以这个笔记并不是一个详尽的Java笔记，而只是记录我所遗忘或需要加强记忆的部分。

基础发展历史  1995年sun公司推出Java语言，200">
<meta name="twitter:image" content="http://img.mukewang.com/53689f74000187be03800330.jpg">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"hide"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 6273747008482182000,
      author: '博主'
    }
  };
</script>

  <title> 再看Java--imooc三季Java视频笔记 | 小牛的博客 </title>
</head>


  	 <!-- custom analytics part create by xiamo -->
<script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
<script>AV.initialize("rk1g6SMHjihkc91LeztBMEds-gzGzoHsz", "Jo2C9gz7OeLrBDlGK1IwlU7U");</script>
<script>
function showTime(Counter) {
	var query = new AV.Query(Counter);
	$(".leancloud_visitors").each(function() {
		var url = $(this).attr("id").trim();
		query.equalTo("url", url);
		query.find({
			success: function(results) {
				if (results.length == 0) {
					var content = $(document.getElementById(url)).text() + ': 0';
					$(document.getElementById(url)).text(content);
					return;
				}
				for (var i = 0; i < results.length; i++) {
					var object = results[i];
					var content = $(document.getElementById(url)).text() + ': ' + object.get('time');
					$(document.getElementById(url)).text(content);
				}
			},
			error: function(object, error) {
				console.log("Error: " + error.code + " " + error.message);
			}
		});

	});
}

function addCount(Counter) {
	var Counter = AV.Object.extend("Counter");
	url = $(".leancloud_visitors").attr('id').trim();
	title = $(".leancloud_visitors").attr('data-flag-title').trim();
	var query = new AV.Query(Counter);
	query.equalTo("url", url);
	query.find({
		success: function(results) {
			if (results.length > 0) {
				var counter = results[0];
				counter.fetchWhenSave(true);
				counter.increment("time");
				counter.save(null, {
					success: function(counter) {
						var content = $(document.getElementById(url)).text() + ': ' + counter.get('time');
						$(document.getElementById(url)).text(content);
					},
					error: function(counter, error) {
						console.log('Failed to save Visitor num, with error message: ' + error.message);
					}
				});
			} else {
				var newcounter = new Counter();
				newcounter.set("title", title);
				newcounter.set("url", url);
				newcounter.set("time", 1);
				newcounter.save(null, {
					success: function(newcounter) {
					    console.log("newcounter.get('time')="+newcounter.get('time'));
						var content = $(document.getElementById(url)).text() + ': ' + newcounter.get('time');
						$(document.getElementById(url)).text(content);
					},
					error: function(newcounter, error) {
						console.log('Failed to create');
					}
				});
			}
		},
		error: function(error) {
			console.log('Error:' + error.code + " " + error.message);
		}
	});
}
$(function() {
	var Counter = AV.Object.extend("Counter");
	if ($('.leancloud_visitors').length == 1) {
		addCount(Counter);
	} else if ($('.post-title-link').length > 1) {
		showTime(Counter);
	}
}); 
</script>


<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?91540d4bebff2d97ac5c297856d63ce5";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">小牛的博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                再看Java--imooc三季Java视频笔记
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-03T12:30:44+08:00" content="2016-09-03">
              2016-09-03
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/我爱学习/" itemprop="url" rel="index">
                    <span itemprop="name">我爱学习</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/03/imooc-java-vedio-note/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/03/imooc-java-vedio-note/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/09/03/imooc-java-vedio-note/" class="leancloud_visitors" data-flag-title="再看Java--imooc三季Java视频笔记">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>开学就要大四了，校招也要开始了。想想自己的能力，感觉差了太多太多，暑假都不敢出去玩，想着多花点时间复习总结一下以前的知识，找工作时能用的到。</p>
<p>Java是我大一时自学的，现在会写但是很多没用到的概念全给忘了，于是就想复习一下。因为我已经有了一定的基础知识，所以这个笔记并不是一个详尽的Java笔记，而只是记录我所遗忘或需要加强记忆的部分。</p>
<hr>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h2><p>  1995年sun公司推出Java语言，2009年Oracle公司收购sun公司</p>
<h2 id="JDK环境变量配置"><a href="#JDK环境变量配置" class="headerlink" title="JDK环境变量配置"></a>JDK环境变量配置</h2><p>JAVA_HOME：配置JDK安装路径<br>PATH/path：配置JDK命令文件的位置，bin<br>CLASSPATH：配置类库文件的位置，lib</p>
<h2 id="Java中的注释"><a href="#Java中的注释" class="headerlink" title="Java中的注释"></a>Java中的注释</h2><p>Java有三种类型：单行注释、多行注释、文档注释<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span>&#123;</span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 文档注释</span><br><span class="line"> * <span class="doctag">@author</span> niujiajun</span><br><span class="line"> * <span class="doctag">@version</span> v1.0</span><br><span class="line"> */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//System.out.println("Java"); 单行注释</span></span><br><span class="line">System.out.println(<span class="string">"imooc"</span>);</span><br><span class="line"><span class="comment">/* 多行注释，以/*开始，以*/</span>结束</span><br><span class="line">         * System.out.println(<span class="string">"Oracle"</span>);</span><br><span class="line"> * System.out.println(<span class="string">"MySQL"</span>);</span><br><span class="line">     */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="文档注释：以-开始，以-结束"><a href="#文档注释：以-开始，以-结束" class="headerlink" title="文档注释：以/*开始，以/结束"></a>文档注释：以/<em>*开始，以</em>/结束</h3><p>使用文档注释时还可以使用 javadoc 标记，生成更详细的文档信息：</p>
<pre><code>@author 标明开发该类模块的作者

@version 标明该类模块的版本

@see 参考转向，也就是相关主题

@param 对方法中某参数的说明

@return 对方法返回值的说明

@exception 对方法可能抛出的异常进行说明
</code></pre><ul>
<li>多行注释：以/<em>开始，以</em>/结束</li>
<li>单行注释：在行前加//<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2></li>
</ul>
<p>在System.out.println()输出时，需要比较变量或处理变量只要加括号就可以了，如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">16</span>;</span><br><span class="line"><span class="keyword">double</span> b=<span class="number">9.5</span>;</span><br><span class="line">System.out.println(<span class="string">"a等于b："</span> + (a == b));</span><br></pre></td></tr></table></figure></p>
<p>输出结果是<br>a等于b: false</p>
<p>print和println的区别是后者会换行</p>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>输入需要用到java.util.Scanner包<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);<span class="comment">//建立Scanner对象</span></span><br><span class="line"><span class="keyword">int</span> i = input.nextInt();<span class="comment">//新建整型变量接收输入的数据</span></span><br></pre></td></tr></table></figure></p>
<h2 id="javadoc生成文档"><a href="#javadoc生成文档" class="headerlink" title="javadoc生成文档"></a>javadoc生成文档</h2><p>通过javadoc命令从文档注释中提取内容，生成程序的 API 帮助文档<br><img src="http://img.mukewang.com/53689f74000187be03800330.jpg" alt="javadoc" title="javadoc"><br>javadoc -d 文件夹名称 java文件</p>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="算术运算符-，–"><a href="#算术运算符-，–" class="headerlink" title="算术运算符++，–"></a>算术运算符++，–</h2><p>++自增1，–自减1，自增和自减运算符只能用于操作变量，不能直接用于操作数值或常量！例如 5++ 、 8– 等写法都是错误的。</p>
<p>++ 和 – 既可以出现在操作数的左边，也可以出现在右边，但结果是不同滴</p>
<h3 id="左边"><a href="#左边" class="headerlink" title="左边"></a>左边</h3><p><img src="http://upload-images.jianshu.io/upload_images/1849253-75fba879962153ee.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>运行结果：<br><img src="http://upload-images.jianshu.io/upload_images/1849253-18d186c6a34c13e0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="右边"><a href="#右边" class="headerlink" title="右边"></a>右边</h3><p><img src="http://upload-images.jianshu.io/upload_images/1849253-a76821117741a454.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>运行结果：<br><img src="http://upload-images.jianshu.io/upload_images/1849253-e3e620a80c3c1f9a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p><img src="http://upload-images.jianshu.io/upload_images/1849253-d29011d32a54c773.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h1 id="关于switch"><a href="#关于switch" class="headerlink" title="关于switch"></a>关于switch</h1><p>1、switch 后面小括号中表达式的值必须是<strong>整型或字符型</strong><br>2、case 后面的值<strong>可以是常量数值</strong>，如 1、2；也<strong>可以是一个常量表达式</strong>，如 2+2 ；但不能是变量或带有变量的表达式，如 a * 2。<br>3、可以把功能相同的 case 语句合并起来，如<br><img src="http://upload-images.jianshu.io/upload_images/1849253-dd2addc410aa1b1d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h2><p>数组的声明有两种方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数组的元素类型  数组名[];</span><br><span class="line"></span><br><span class="line">数组的元素类型[]  数组名；</span><br></pre></td></tr></table></figure></p>
<h2 id="分配空间"><a href="#分配空间" class="headerlink" title="分配空间"></a>分配空间</h2><p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名 = new 数据类型[数组长度]；</span><br></pre></td></tr></table></figure></p>
<p>也可同时进行声明和分配空间：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型[] 数组名 = new 数据类型[数组长度]；</span><br></pre></td></tr></table></figure></p>
<p><strong>此时数组长度不能为空</strong></p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型 数组名[] = &#123;值1，值2，值3...&#125;;</span><br></pre></td></tr></table></figure>
<p>又或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型 数组名[] = new 数据类型[]&#123;值1，值2，值3...&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>此时数据类型后的[]中应为空</strong></p>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>以升序排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(数组名);</span><br></pre></td></tr></table></figure></p>
<p>转为String<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.toString(数组名);</span><br></pre></td></tr></table></figure></p>
<p><strong>PS：此方法并不是返回排序后的数组而是将原数组排序</strong></p>
<h1 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h1><h1 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h1><p>如果同一个类中包含了两个或两个以上方法名相同、<strong>方法参数的个数</strong>、<strong>顺序</strong>或<strong>类型</strong>不同的方法，则称为方法的重载，也可称该方法被重载了。如下所示 4 个方法名称都为 show ，但方法的参数有所不同，因此都属于方法的重载：<br><img src="http://upload-images.jianshu.io/upload_images/1849253-6dd540304075b70a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><strong>PS:方法的重载与方法的修饰符或返回值没有关系</strong></p>
<h2 id="成员变量和局部变量的区别"><a href="#成员变量和局部变量的区别" class="headerlink" title="成员变量和局部变量的区别"></a>成员变量和局部变量的区别</h2><ol>
<li><p>Java会给成员变量赋一个初始值</p>
</li>
<li><p>Java不会给局部变量赋初始值</p>
</li>
<li><p>成员变量和局部变量同名时，在方法内局部变量有更高的优先级</p>
</li>
</ol>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><ol>
<li><p>构造方法是定义在Java类中的一个用来初始化对象的方法，名称与类名相同<strong>没有返回值</strong>。</p>
</li>
<li><p>当没有指定构造方法时，系统会自动添加无参的构造方法。</p>
</li>
<li><p>当有指定的构造方法时，无论是有参，无参的构造方法，都不会自动添加无参的构造方法。</p>
</li>
</ol>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>使用 static 可以修饰变量、方法和代码块。被static修饰的变量叫类变量，否则叫实例变量；被static修饰的方法叫类方法或静态方法，否则叫实例方法。</p>
<p>类变量和类方法属于类，实例变量和实例方法属于对象。当类第一次使用时，只会给类方法和类变量分配内存，而不会给实例变量和实例方法分配内存。只有创建对象后，才会给实例变量和实例方法分配内存。类的所有对象共用类变量和类方法，而实例变量和实例方法只被所创建的对象使用。</p>
<p>静态成员可以使用类名直接访问，也可以使用对象名进行访问，推荐用类名访问。</p>
<p>实例方法可以调用该类中的实例方法或类方法，而类方法只能调用该类的类方法，不能直接调用实例方法。如果希望在静态方法中调用非静态变量，可以通过创建类的对象，然后通过对象来访问非静态变量。</p>
<p>在类的声明中，可以包含多个初始化块，当创建类的实例时，就会依次执行这些代码块。如果使用 static 修饰初始化块，就称为静态初始化块。</p>
<p>需要特别注意：<strong>静态初始化块只在类加载时执行，且只会执行一次，同时静态初始化块只能给静态变量赋值，不能初始化普通的成员变量</strong><br>例如：<br><img src="http://upload-images.jianshu.io/upload_images/1849253-b236f1e6f6ba397b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>运行结果：<br><img src="http://upload-images.jianshu.io/upload_images/1849253-45e8dc811a559db1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>通过输出结果，我们可以看到，程序运行时静态初始化块最先被执行，然后执行普通初始化块，最后才执行构造方法。由于静态初始化块只在类加载时执行一次，所以当再次创建对象 hello2 时并未执行静态初始化块。</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>面向对象的三大特性：继承，封装和多态</p>
<ol>
<li><p>封装的概念：将类的信息隐藏在类的内部，不允许外部程序直接访问，而是通过该类提供的方法实现对隐藏信息的操作和访问。</p>
</li>
<li><p>封装的好处：</p>
</li>
</ol>
<ul>
<li>只能通过规定的方法访问数据。</li>
<li>隐藏类的实例细节，方便修改和实现。</li>
</ul>
<h2 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h2><table>
<thead>
<tr>
<th>访问修饰符</th>
<th>本类</th>
<th>同包</th>
<th>子类</th>
<th>其他</th>
</tr>
</thead>
<tbody>
<tr>
<td>private</td>
<td>√</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>缺省/默认</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr>
<td>protected</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>public</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
</tbody>
</table>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><ol>
<li><p>定义：<br>内部类（ Inner Class ）就是定义在另外一个类里面的类。与之对应，包含内部类的类被称为外部类。</p>
</li>
<li><p>作用</p>
<ul>
<li><p>内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类</p>
</li>
<li><p>内部类的方法可以直接访问外部类的所有数据，包括私有的数据</p>
</li>
<li><p>内部类所实现的功能使用外部类同样可以实现，只是有时使用内部类更方便</p>
</li>
</ul>
</li>
</ol>
<p>3.分类</p>
<ul>
<li><p>成员内部类</p>
</li>
<li><p>静态内部类</p>
</li>
<li><p>方法内部类</p>
</li>
<li><p>匿名内部类</p>
</li>
</ul>
<h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><ol>
<li><p>内部类定义在外部类的内部，相当于外部类的一个成员变量的位置，内部类可以使用任意访问控制符，如 public 、 protected 、 private 等</p>
</li>
<li><p>内部类中定义的 test() 方法可以直接访问外部类中的数据，而不受访问控制符的影响，如直接访问外部类中的私有属性a</p>
</li>
<li><p>定义了成员内部类后，必须使用外部类对象来创建内部类对象，而不能直接去 new 一个内部类对象，即：<strong>内部类 对象名 = 外部类对象.new 内部类( )</strong>;</p>
</li>
<li><p>外部类是不能直接使用内部类的成员和方法滴</p>
</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/1849253-91440ad609a91a6c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>可先创建内部类的对象，然后通过内部类的对象来访问其成员变量和方法。</p>
<p> 5.如果外部类和内部类具有相同的成员变量或方法，内部类默认访问自己的成员变量或方法，如果要访问外部类的成员变量，可以使用 this 关键字。如：<br><img src="http://upload-images.jianshu.io/upload_images/1849253-f2d8e31eb3c31c23.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>1、 静态内部类不能直接访问外部类的非静态成员，但可以通过<strong> new 外部类().成员</strong> 的方式访问 </p>
<p>2、 如果外部类的静态成员与内部类的成员名称相同，可通过“类名.静态成员”访问外部类的静态成员；如果外部类的静态成员与内部类的成员名称不相同，则可通过“成员名”直接调用外部类的静态成员</p>
<p>3、 创建静态内部类的对象时，不需要外部类的对象，可以直接创建 <strong>内部类 对象名= new 内部类();</strong><br><img src="http://upload-images.jianshu.io/upload_images/1849253-9f33adaa26c93b03.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="方法内部类"><a href="#方法内部类" class="headerlink" title="方法内部类"></a>方法内部类</h2><p>方法内部类就是内部类定义在外部类的方法中，方法内部类只在该方法的内部可见，即只在该方法内可以使用。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1849253-37f0bf7c69924d55.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><strong>注意：</strong>由于方法内部类不能在外部类的方法以外的地方使用，因此方法内部类不能使用访问控制符和 static 修饰符。</p>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>继承是Java面向对象编程的一个重要特点，指一种由已有类创建新类的机制。利用继承，可以先编写一个共有属性的一般类，再根据一般类编写具有特殊属性的新类。新类继承一般类的属性和方法，并根据需要增加新的属性和方法。</p>
<p>所谓子类继承父类的成员变量和方法，就好像他们是在子类中直接声明的一样，可以被子类中自己定义的任何实例方法操作和调用。</p>
<p>子类对父类成员变量和方法的继承性：</p>
<table>
<thead>
<tr>
<th></th>
<th>private</th>
<th>缺省/默认</th>
<th>protected</th>
<th>public</th>
</tr>
</thead>
<tbody>
<tr>
<td>同一包</td>
<td></td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>不同包</td>
<td></td>
<td></td>
<td>√</td>
<td>√</td>
</tr>
</tbody>
</table>
<h2 id="继承的初始化顺序"><a href="#继承的初始化顺序" class="headerlink" title="继承的初始化顺序"></a>继承的初始化顺序</h2><ol>
<li><p>先初始化父类再初始化子类</p>
</li>
<li><p>先初始化属性，再初始化构造方法</p>
</li>
</ol>
<p>总的顺序是先初始化父类的属性，再初始化父类的构造方法，然后初始化子类的属性，最后初始化子类的构造方法。</p>
<h2 id="重写-override"><a href="#重写-override" class="headerlink" title="重写@override"></a>重写@override</h2><p>如果子类对继承父类的方法不满意，可以重写从父类继承的方法，当调用方法时会优先调用子类的方法。<br>注意：</p>
<ul>
<li>返回值类型</li>
<li>方法名</li>
<li>参数类型及个数</li>
</ul>
<p>都要与父类继承的方法相同，才叫方法的重写</p>
<h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>final关键字可以修饰类，方法，属性和变量</p>
<ul>
<li><p>final修饰类，则类不允许被继承</p>
</li>
<li><p>final修饰方法，则方法不允许被覆盖（重写）</p>
</li>
<li><p>final修饰属性，则该类的属性不会进行隐式的初始化（java自动赋初值），初始化时必须赋一个值，或在构造方法中赋值（二选一）</p>
</li>
<li><p>final修饰变量，则该变量只能赋一次值，即为常量</p>
</li>
</ul>
<h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><p>在子类的内部使用，可以代表父类对象。既可以访问父类的属性也可以访问父类的方法。<br>注意：</p>
<ul>
<li><p>子类的构造过程中必须调用父类的构造方法。</p>
</li>
<li><p>如果子类的构造方法中没有显式调用父类的构造方法，则系统默认调用父类无参的构造方法，即隐式调用，super();</p>
</li>
<li><p>如果显式调用构造方法，必须在子类构造方法的第一行。</p>
</li>
<li><p>如果子类构造中既没有显式调用父类的构造方法，而父类又没有无参的构造方法，则编译出错。</p>
</li>
</ul>
<h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><p>Object类是所有类的父类，如果一个类没有使用extends关键字明确标识继承另一个类，那么这个类默认继承Object类。</p>
<p>Object类中的方法，适合所有子类。</p>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><h2 id="java中的多态"><a href="#java中的多态" class="headerlink" title="java中的多态"></a>java中的多态</h2><p>字面上的意思是对象的多种形态。</p>
<ol>
<li>引用多态：父类的引用既可以指向本类的对象，也可以指向子类的对象，如：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Animal obj1 = <span class="keyword">new</span> Animal();<span class="comment">//指向本类</span></span><br><span class="line">Animal obj2 = <span class="keyword">new</span> Dog();<span class="comment">//指向子类</span></span><br></pre></td></tr></table></figure>
<ol>
<li>方法多态：</li>
</ol>
<ul>
<li><p>创建本类对象时，调用的方法为本类方法</p>
</li>
<li><p>创建子类对象时，调用的方法是子类重写的方法或继承的方法，不能调用子类独有的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> *  接上段代码</span><br><span class="line"> */</span></span><br><span class="line">obj1.eat();<span class="comment">//调用本类方法</span></span><br><span class="line">obj2.eat();<span class="comment">//调用子类重写或继承的方法</span></span><br><span class="line"><span class="comment">//obj2.watchDoor();不能调用子类独有的方法</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="多态中的引用类型转换"><a href="#多态中的引用类型转换" class="headerlink" title="多态中的引用类型转换"></a>多态中的引用类型转换</h2><ol>
<li>向上类型转换（隐式/自动类型转换），是小类型到大类型的转换</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Dog dog = <span class="keyword">new</span> Dog();</span><br><span class="line">Animal animal = dog;<span class="comment">//向上类型转换</span></span><br></pre></td></tr></table></figure>
<ol>
<li>向下类型转换（强制类型转换），是大类型到小类型的转换，存在溢出的风险</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Dog dog = <span class="keyword">new</span> Dog();</span><br><span class="line">Animal animal = dog;</span><br><span class="line">Dog dog = (Dog)animal;</span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * Animal animal = new Animal();</span><br><span class="line"> * Dog dog = (Dog)animal;</span><br><span class="line"> * 编译不出错，运行过程中出错。</span><br><span class="line"> */</span></span><br></pre></td></tr></table></figure>
<h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>instanceof运算符是二目运算符，左边的操作元是一个对象，右边是一个类。当左边的对象是右边的类或子类创建的对象时，返回true，否则返回false。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 此例可以转换</span><br><span class="line"> */</span></span><br><span class="line">Dog dog = <span class="keyword">new</span> Dog();</span><br><span class="line">Animal animal = dog;</span><br><span class="line"><span class="keyword">if</span>(animal <span class="keyword">instanceof</span> Dog)&#123;</span><br><span class="line">      Dog dog = (Dog) animals; </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"无法转换"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="抽象类abstract"><a href="#抽象类abstract" class="headerlink" title="抽象类abstract"></a>抽象类abstract</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>使用abstract修饰的类叫抽象类</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li><p>在某些情况下，某个父类只是知道其子类应该包含怎样的方法，但无法准确知道子类如何实现这些方法</p>
</li>
<li><p>从多个具有相同特征的类中抽象出一个抽象类，以这个抽象类作为子类的模板，从而避免了子类设计的随意性</p>
</li>
</ul>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>限制规定子类必须实现某些方法，但不关注实现细节。</p>
<h3 id="使用规则"><a href="#使用规则" class="headerlink" title="使用规则"></a>使用规则</h3><ul>
<li><p>abstract定义抽象类</p>
</li>
<li><p>abstract定义抽象方法，只有声明，不需要实现</p>
</li>
<li><p>包含抽象方法的类是抽象类</p>
</li>
<li><p>抽象类中可以包含普通方法，也可以没有抽象方法</p>
</li>
<li><p>抽象类不能直接创建，可以定义引用变量</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 父类</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;<span class="comment">//abstract定义抽象类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>;<span class="comment">//abstract定义抽象方法，只有声明，不需要实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 子类1</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"狗吃骨头"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"看门"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 子类2</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"猫吃鱼"</span>);<span class="comment">//子类要实现父类的抽象方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"捉老鼠"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 初始化</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Animal dog = <span class="keyword">new</span> Dog();<span class="comment">//抽象类不能直接创建，可以定义引用变量，</span></span><br><span class="line">        <span class="comment">//不能直接创建，Animal animal = new Animal();</span></span><br><span class="line">        dog.eat();</span><br><span class="line">        dog.work();</span><br><span class="line">        Animal cat = <span class="keyword">new</span> Cat();</span><br><span class="line">        cat.eat();</span><br><span class="line">        cat.work();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>类是一种具体实现体，而接口定义了某一些类所需要遵守的规范，接口不关心这些类的内部数据，也不关心这些类里方法的实现细节，它只规定这些类里必须提供某些方法。</p>
<h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>接口通过interface关键字来定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 interface 接口的名字</span><br></pre></td></tr></table></figure></p>
<p>接口就是用来被继承，被实现的，修饰符不能使用private和protected，一般建议用public。</p>
<ul>
<li><p>接口中的属性只能是常量，即定义是不添加<strong> public static final </strong>修饰符，系统也会加上。</p>
</li>
<li><p>接口中的方法只能是抽象方法，即使定义时不添加pubic abstract 修饰符，系统也会自动加上。</p>
</li>
<li><p>即使不给接口添加abstract关键字，系统也会默认加上。</p>
</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>接口可以同时实现多个，必须放在继承之后。</p>
<p>同abstract类似，接口不能直接创建，但可以用接口的引用指向一个实现了接口的对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ClassA implements InterfaceA</span></span><br><span class="line">InterfaceA a = <span class="keyword">new</span> ClassA();</span><br></pre></td></tr></table></figure></p>
<h2 id="abstract类与接口的比较"><a href="#abstract类与接口的比较" class="headerlink" title="abstract类与接口的比较"></a>abstract类与接口的比较</h2><ol>
<li><p>abstract类和接口都可以有abstract方法</p>
</li>
<li><p>接口只可以有常量，不能有变量，而abstract类中既可以有常量也可以有变量</p>
</li>
<li><p>abstract类可以有非abstract方法，接口不可以</p>
</li>
</ol>
<p>在设计程序时应当根据具体的分析来确定是使用抽象类还是接口。abstract类除了提供重要的需要子类去实现的abstract方法外，还可以提供子类可以继承的变量和非abstract方法。如果某个问题需要使用继承才能更好的解决，比如子类除了需要实现父类的abstract方法外，还需要从父类继承一些变量或一些重要的非abstract方法，就可以考虑使用abstract类。如果某个问题不需要继承，只是需要若干个类给出某些重要的abstract方法的实现细节，就可以考虑使用接口。</p>
<h1 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h1><ul>
<li>实例1:不使用匿名内部类来实现抽象方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"eat something"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Child();<span class="comment">//从这对比下面的例子可以看出匿名类实际上是子类</span></span><br><span class="line">        p.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果：</strong>eat something</p>
<p>可以看到，我们用Child继承了Person类，然后实现了Child的一个实例，将其向上转型为Person类的引用</p>
<p>但是，如果此处的Child类只使用一次，那么将其编写为独立的一个类岂不是很麻烦？</p>
<p>这个时候就引入了匿名内部类</p>
<ul>
<li>实例2：匿名内部类的基本实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> classPerson &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;<span class="comment">//匿名类的类体不可以声明static成员变量和static方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person() &#123;</span><br><span class="line">             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             System.out.println(<span class="string">"eat something"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        p.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果：</strong>eat something</p>
<p>可以看到，我们直接将抽象类Person中的方法在大括号中实现了</p>
<p>这样便可以省略一个类的书写</p>
<p>并且，匿名内部类还能用于接口上</p>
<ul>
<li>实例3：在接口上使用匿名内部类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p =<span class="keyword">new</span> Person() &#123;</span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                   System.out.println(<span class="string">"eat something"</span>);</span><br><span class="line">               &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        p.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果：</strong>eat something</p>
<p>由上面的例子可以看出，只要一个类是抽象的或是一个接口，那么其子类中的方法都可以使用匿名内部类来实现</p>
<p>摘自<a href="http://www.cnblogs.com/nerxious/archive/2013/01/25/2876489.html" title="匿名内部类的解释" target="_blank" rel="external">匿名内部类的解释</a></p>
<ul>
<li>高阶：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Product</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAnonymous</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Product p)</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"购买了一个"</span>+p.getName()+<span class="string">"，花掉了"</span>+p.getPrice());  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </span><br><span class="line">    TestAnonymous ta = <span class="keyword">new</span> TestAnonymous();  </span><br><span class="line">    ta.test(<span class="keyword">new</span> Product()&#123;  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">567</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"AGP显卡"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    &#125;);  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="异常类"><a href="#异常类" class="headerlink" title="异常类"></a>异常类</h1><p>所谓异常就是程序运行时可能出现一些错误。</p>
<p>所有的异常类都是Exception的子类，而Exception和Error又同为Throwable的子类。</p>
<p>Error类的子类又有虚拟机错误（VitrualMachineError）和线程锁死（ThreadDeath）等一类，这类错误一般不会出现，出现的话程序就彻底崩溃了。</p>
<p>Exception类一般是由编码，环境，用户操作输入出现等问题所引起的，其子类包括运行时异常（RunTimeException）和检查异常。</p>
<p>运行时异常又包含空指针异常，数组下标越界异常，类型转换异常，算术异常等子类，它们都是由JVM自动捕获自动抛出，出现运行时异常一般是代码编写问题。</p>
<p>检查异常则多种多样，如文件异常（IOException），SQL异常（SQLException）等，这类异常需要自己手动添加捕获处理语句。<br><img src="http://upload-images.jianshu.io/upload_images/1849253-6d64f752ee7f8277.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="try-catch语句"><a href="#try-catch语句" class="headerlink" title="try-catch语句"></a>try-catch语句</h2><p>try-catch语句可以用来处理异常，其中try部分捕获异常，catch部分处理异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//包含可能发生异常的语句</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(ExceptionSubClass e)&#123;</span><br><span class="line">   <span class="comment">//处理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(ExceptionSubClass2 e)&#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>catch中的参数都是Exception类或Exception的子类，捕获异常时应遵循先小后大的原则。</p>
<p>异常对象可以通过以下方法得到或输出错误信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printStackTrace</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="finally子语句"><a href="#finally子语句" class="headerlink" title="finally子语句"></a>finally子语句</h2><p>语法格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;&#125;</span><br><span class="line"><span class="keyword">catch</span>(ExceptionSubClass e)&#123;&#125;</span><br><span class="line"><span class="keyword">finally</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>其执行机制是，在执行try-catch语句后，执行finally子语句。也就是说，无论在try部分是否发生过异常，finally子语句都会被执行。</p>
<p>注意：</p>
<ul>
<li><p>如果在try-catch语句中执行了return语句，那么finally子语句仍然会被执行</p>
</li>
<li><p>如果在try-catch语句中执行了程序退出代码，即执行了System.exit(0)；，将不执行finally子语句。</p>
</li>
<li><p>如果try-catch-finally语句都没有return，则会调用语句块之外的return，注意，如果方法体中执行了return语句，则其后的语句都不会再执行。</p>
</li>
</ul>
<h2 id="异常抛出"><a href="#异常抛出" class="headerlink" title="异常抛出"></a>异常抛出</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> 方法名（参数） <span class="keyword">throws</span> 异常&#123;</span><br><span class="line"><span class="comment">//调用会抛出异常的方法或：</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h3><p>将产生的异常抛出，用在方法体内</p>
<h3 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h3><p>声明将要抛出何种类型的异常，可以抛出一个或多个异常</p>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>需要继承Exception类或其子类。</p>
<h3 id="异常链"><a href="#异常链" class="headerlink" title="异常链"></a>异常链</h3><p>一个异常如果是由另一个异常引起的，这种链式反应就可以叫做异常链。如在try-catch捕获到一个异常后再创建一个新的异常，从而将旧的异常包装成新的异常，然后抛出新的异常。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception1 e)&#123;</span><br><span class="line">    Exception2 e2 = <span class="keyword">new</span> Exception2(<span class="string">"异常"</span>);</span><br><span class="line">    e2.initCause(e2);</span><br><span class="line">    <span class="keyword">throw</span> e2;</span><br><span class="line">    <span class="comment">//或者</span></span><br><span class="line">    <span class="comment">// Exception2 e2 = new Exception2(e);</span></span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><p>首先需要注意的是，和Java中的包装类一样，当通过赋值等号给变量赋相同的值的时候，系统会默认将其指向同一块内存，而通过new方法创建对象时，不管内容是否相同，都会分配一块新的内存，此时使用 ”==” 比较时也为 ”false”。如果只需比较内容是否相同，应使用 ”equals()” 方法。</p>
<p><strong> ==: 判断两个字符串在内存中首地址是否相同，即判断是否是同一个字符串对象 </strong></p>
<p><strong> equals(): 比较存储在两个字符串对象中的内容是否一致 </strong></p>
<p>如：<br><img src="http://upload-images.jianshu.io/upload_images/1849253-c17257f0a26d3e27.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>结果：<br><img src="http://upload-images.jianshu.io/upload_images/1849253-8301fb3d963097a6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="字符串的不变性"><a href="#字符串的不变性" class="headerlink" title="字符串的不变性"></a>字符串的不变性</h2><p>String 对象创建后则不能被修改，是不可变的，所谓的修改其实是创建了新的对象，所指向的内存空间不同。如果需要一个可以改变的字符串，我们可以使用StringBuffer或者StringBuilder。</p>
<h2 id="String类常用方法"><a href="#String类常用方法" class="headerlink" title="String类常用方法"></a>String类常用方法</h2><p><img src="http://upload-images.jianshu.io/upload_images/1849253-1bb4d5da49650029.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>注意：</p>
<ul>
<li><p>字符串 str 中字符的索引从0开始，范围为 0 到 str.length()-1</p>
</li>
<li><p>使用 indexOf 进行字符或字符串查找时，如果匹配返回位置索引；如果没有匹配结果，返回 -1</p>
</li>
<li><p>使用 substring(beginIndex , endIndex) 进行字符串截取时，包括 beginIndex 位置的字符，不包括 endIndex 位置的字符</p>
</li>
</ul>
<h2 id="StringBuilder和StringBuffer"><a href="#StringBuilder和StringBuffer" class="headerlink" title="StringBuilder和StringBuffer"></a>StringBuilder和StringBuffer</h2><p>因为String字符串具有不变性，每次操作字符串都要创建新的字符串对象，当频繁操作字符串时，就会额外产生很多临时变量。使用 StringBuilder 或 StringBuffer 就可以避免这个问题。至于 StringBuilder 和StringBuffer ，它们基本相似，不同之处，StringBuffer 是线程安全的，而 StringBuilder 则没有实现线程安全功能，所以性能略高。因此一般情况下，如果需要创建一个内容可变的字符串对象，应优先考虑使用 StringBuilder 类。</p>
<p>常用方法：<br><img src="http://upload-images.jianshu.io/upload_images/1849253-135d1ea15f328ba2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>相比String类，StringBuilder和StringBuffer多了追加和插入操作。这些操作修改了 str 对象的值，而没有创建新的对象，这就是 StringBuilder 和 String 最大的区别。</p>
<h1 id="Java中的包装类"><a href="#Java中的包装类" class="headerlink" title="Java中的包装类"></a>Java中的包装类</h1><p>Java中有int、float、double、boolean、char 等基本数据类型，基本类型不具备对象的特性的，不能调用方法、功能简单。。。，为了让基本数据类型也具备对象的特性， Java 为每个基本数据类型都提供了一个包装类，这样我们就可以像操作对象那样来操作基本数据类型。</p>
<p>基本类型和包装类之间的对应关系：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1849253-55c0b7a83b773ad6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>包装类主要提供了两大类方法：</p>
<ul>
<li><p>将本类型和其他基本类型进行转换的方法</p>
</li>
<li><p>将字符串和本类型及包装类互相转换的方法</p>
</li>
</ul>
<h2 id="以Interger举例"><a href="#以Interger举例" class="headerlink" title="以Interger举例"></a>以Interger举例</h2><p>Integer 包装类的构造方法：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1849253-e15199e52e35054f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>如下代码所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1849253-542be2a4dee87d26.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>Integer包装类的常用方法：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1849253-f3b883f2dbf537b4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="基本类型和包装类之间的互相转换（以-Integer-为例）"><a href="#基本类型和包装类之间的互相转换（以-Integer-为例）" class="headerlink" title="基本类型和包装类之间的互相转换（以 Integer 为例）"></a>基本类型和包装类之间的互相转换（以 Integer 为例）</h2><p><img src="http://upload-images.jianshu.io/upload_images/1849253-fa854885dff36fd7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>在 JDK1.5 引入自动装箱和拆箱的机制后，包装类和基本类型之间的转换就更加轻松便利了。</p>
<p><strong>装箱：</strong>把基本类型转换成包装类，使其具有对象的性质，又可分为手动装箱和自动装箱</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1849253-58c44869a4d8c83b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><strong>拆箱：</strong>和装箱相反，把包装类对象转换成基本类型的值，又可分为手动拆箱和自动拆箱</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1849253-1ff6668d7fd1c2a5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="Java-中基本类型和字符串之间的转换（以-Integer-为例）"><a href="#Java-中基本类型和字符串之间的转换（以-Integer-为例）" class="headerlink" title="Java 中基本类型和字符串之间的转换（以 Integer 为例）"></a>Java 中基本类型和字符串之间的转换（以 Integer 为例）</h2><p>基本类型转换为字符串有三种方法：</p>
<ol>
<li><p>使用包装类的 toString() 方法</p>
</li>
<li><p>使用String类的 valueOf() 方法</p>
</li>
<li><p>用一个空字符串加上基本类型，得到的就是基本类型数据对应的字符串</p>
</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/1849253-01c92908887d385f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>字符串转换成基本类型有两种方法：</p>
<ol>
<li><p>调用包装类的 parseXxx 静态方法</p>
</li>
<li><p>调用包装类的 valueOf() 方法转换为基本类型的包装类，会自动拆箱</p>
</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/1849253-92c4a5f7601fc3bf.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>PS：其他基本类型与字符串的相互转化这里不再一一列出，方法都类似</p>
<h1 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h1><h2 id="使用-Date-和-SimpleDateFormat-类表示时间"><a href="#使用-Date-和-SimpleDateFormat-类表示时间" class="headerlink" title="使用 Date 和 SimpleDateFormat 类表示时间"></a>使用 Date 和 SimpleDateFormat 类表示时间</h2><p>在程序开发中，经常需要处理日期和时间的相关数据，此时我们可以使用 java.util 包中的 Date 类。这个类最主要的作用就是获取当前时间，我们来看下 Date 类的使用：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1849253-3a8148ed5a3248fa.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>使用 Date 类的<strong>默认无参构造方法</strong>创建出的对象就代表<strong>当前时间</strong>，我们可以直接输出 Date 对象显示当前的时间，显示的结果如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1849253-c193c299d13ac86d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>其中， Wed 代表 Wednesday (星期三)， Jun 代表 June (六月)， 11 代表 11 号， CST 代表 China Standard Time (中国标准时间，也就是北京时间，东八区)。</p>
<p>从上面的输出结果中，我们发现，默认的时间格式不是很友好，与我们日常看到的日期格式不太一样，如果想要按指定的格式进行显示，如 2014-06-11 09:22:30 ，那该怎么做呢？</p>
<p>此时就到了 java.text 包中的 SimpleDateFormat 类大显身手的时候了！！可以使用 SimpleDateFormat 来对日期时间进行格式化，如可以将日期转换为指定格式的文本，也可将文本转换为日期。</p>
<ol>
<li>使用 format() 方法将日期转换为指定格式的文本</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/1849253-57ebf0ee4cb74f5f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>代码中的 “yyyy-MM-dd HH : mm : ss” 为预定义字符串， yyyy 表示四位年， MM 表示两位月份， dd 表示两位日期， HH 表示小时(使用24小时制)， mm 表示分钟， ss 表示秒，这样就指定了转换的目标格式，最后调用 <strong>format() </strong>方法将时间转换为指定的格式的字符串。</p>
<p>运行结果：<strong> 2014-06-11  09:55:48 </strong></p>
<p>2 . 使用 parse() 方法将文本转换为日期</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1849253-57af602db717420a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>代码中的 “yyyy年MM月dd日 HH : mm : ss” 指定了字符串的日期格式，调用 <strong>parse() </strong>方法将文本转换为日期。</p>
<p>运行结果：<br><img src="http://upload-images.jianshu.io/upload_images/1849253-9118fd10a965a7ea.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>一定要注意哦：</p>
<p>1、 调用 SimpleDateFormat 对象的 parse() 方法时可能会出现转换异常，即 ParseException ，因此需要进行异常处理</p>
<p>2、 使用 Date 类时需要导入 java.util 包，使用 SimpleDateFormat 时需要导入 java.text 包</p>
<h2 id="Calendar-类的应用"><a href="#Calendar-类的应用" class="headerlink" title="Calendar 类的应用"></a>Calendar 类的应用</h2><p>Date 类最主要的作用就是获得当前时间，同时这个类里面也具有设置时间以及一些其他的功能，但是由于本身设计的问题，这些方法却遭到众多批评，不建议使用，更推荐使用 Calendar 类进行时间和日期的处理。</p>
<p>java.util.Calendar 类是一个抽象类，可以通过调用 getInstance()静态方法获取一个 Calendar 对象，此对象已由当前日期时间初始化，即默认代表当前时间，如 Calendar c = Calendar.getInstance();</p>
<p>那么如何使用 Calendar 获取年、月、日、时间等信息呢？我们来看下面的代码：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1849253-37ec0caa028093fc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>其中，调用 Calendar 类的 getInstance() 方法获取一个实例，然后通过调用 get() 方法获取日期时间信息，参数为需要获得的字段的值， Calendar.Year 等为 Calendar 类中定义的静态常量。</p>
<p>运行结果：<br><img src="http://upload-images.jianshu.io/upload_images/1849253-c1a25318d26fcdc8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>Calendar 类提供了 getTime() 方法，用来获取 Date 对象，完成 Calendar 和 Date 的转换，还可通过 getTimeInMillis() 方法，获取此 Calendar 的时间值，以毫秒为单位。如下所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1849253-2e9845eb4bb04f8a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>运行结果：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1849253-0b611466346ff542.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="使用-Math-类操作数据"><a href="#使用-Math-类操作数据" class="headerlink" title="使用 Math 类操作数据"></a>使用 Math 类操作数据</h2><p>Math 类位于 java.lang 包中，包含用于执行基本数学运算的方法， Math 类的所有方法都是静态方法，所以使用该类中的方法时，可以直接使用类名.方法名，如： Math.round();</p>
<p>常用的方法：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1849253-f5f843c8d9be8edf.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h1 id="Java集合框架"><a href="#Java集合框架" class="headerlink" title="Java集合框架"></a>Java集合框架</h1><p>Java中的集合类是一种工具，就像是容器，储存任意数量的具有共同属性的对象</p>
<h2 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h2><ul>
<li><p>在类的内部，对数据进行组织</p>
</li>
<li><p>简单而快速的搜索大数量的条目</p>
</li>
<li><p>有的集合接口，提供了一系列排列有序的元素，并且可以在序列中间快速的插入或者删除有关元素</p>
</li>
<li><p>有的集合接口，提供了映射关系，可以通过关键字（key）去快速查找到对应的唯一对象，而这个关键字可以是任意类型</p>
</li>
</ul>
<h2 id="与数组的对比–为何选择集合而不是数组"><a href="#与数组的对比–为何选择集合而不是数组" class="headerlink" title="与数组的对比–为何选择集合而不是数组"></a>与数组的对比–为何选择集合而不是数组</h2><ul>
<li><p>数组的长度固定，集合长度可变</p>
</li>
<li><p>数组只能通过下标访问元素，类型固定，而有的集合可以通过任意类型查找所映射的具体对象</p>
</li>
</ul>
<h2 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h2><p><img src="http://upload-images.jianshu.io/upload_images/1849253-1074e693ab073338.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>Collection存储单个对象，而Map存储键值对。</p>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>集合中的元素可以是任意的对象（其保存的是对象的引用），如果把某个对象放入集合，则会忽略他的类型，而把他当作Object处理，所以通过get方法取出后还需强制类型转化。</p>
<p>泛型则是规定了某个集合只可以存放特定类型及其子类型的对象，会在编译期间进行类型检查，可以直接按指定类型获取集合元素，不需要类型转换。</p>
<p>泛型的声明方法只比普通的集合多一个尖括号加指定类型，如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Course&gt; courses= <span class="keyword">new</span> ArrayList&lt;Course&gt;();</span><br></pre></td></tr></table></figure></p>
<p>操作与普通集合完全相同。</p>
<p><strong> 注意：</strong></p>
<ul>
<li><p>泛型集合中的限定类型，不能使用基本数据类型</p>
</li>
<li><p>可以通过使用包装类限定允许存入的基本数据类型</p>
</li>
</ul>
<p>PS：不适用泛型的普通集合能添加基本类型是因为自动装箱将基本类型转成了包装类。</p>
<h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p>Collection接口是List，Set和Queue接口的父类，定义了增删改查的操作。</p>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><ul>
<li><p>List是元素有序并且可以重复的集合，被称为序列</p>
</li>
<li><p>List可以精确的控制每个元素的插入位置，或删除某个位置的元素</p>
</li>
<li><p>ArrayList–数组序列，是List的一个重要实现类，因为List是接口不能直接创建对象，需要通过ArrayList创建，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List coursesToSelect= <span class="keyword">new</span> ArrayList();</span><br></pre></td></tr></table></figure>
</li>
<li><p>List中，多次添加某个对象，则会创建多个对象，但其指向同一块内存</p>
</li>
<li><p>ArrayList底层是由数组实现的</p>
</li>
</ul>
<h4 id="Add"><a href="#Add" class="headerlink" title="Add"></a>Add</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Course cr1 = <span class="keyword">new</span> Course(<span class="string">"1"</span>, <span class="string">"数据结构"</span>);</span><br><span class="line">coursesToSelect.add(cr1);<span class="comment">//直接添加对象</span></span><br><span class="line"></span><br><span class="line">Course cr2 = <span class="keyword">new</span> Course(<span class="string">"2"</span>, <span class="string">"C语言"</span>);</span><br><span class="line">coursesToSelect.add(<span class="number">0</span>, cr2);<span class="comment">//将对象添加到指定位置，原位置已有内容则和后面内容一起顺延一位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当添加的位置没有按顺序递增时会抛出数组下标越界异常</span></span><br><span class="line"><span class="comment">// Course cr3 = new Course("3", "test");</span></span><br><span class="line"><span class="comment">// coursesToSelect.add(4, cr3);</span></span><br><span class="line"></span><br><span class="line">Course[] course = &#123; <span class="keyword">new</span> Course(<span class="string">"3"</span>, <span class="string">"离散数学"</span>), <span class="keyword">new</span> Course(<span class="string">"4"</span>, <span class="string">"汇编语言"</span>) &#125;;</span><br><span class="line">coursesToSelect.addAll(Arrays.asList(course));<span class="comment">//通过Array.asList()添加一个对象数组</span></span><br><span class="line"></span><br><span class="line">Course[] course2 = &#123; <span class="keyword">new</span> Course(<span class="string">"5"</span>, <span class="string">"高等数学"</span>), <span class="keyword">new</span> Course(<span class="string">"6"</span>, <span class="string">"大学英语"</span>) &#125;;</span><br><span class="line">coursesToSelect.addAll(<span class="number">2</span>, Arrays.asList(course2));<span class="comment">//将对象数组添加到指定位置</span></span><br></pre></td></tr></table></figure>
<h4 id="Remove"><a href="#Remove" class="headerlink" title="Remove"></a>Remove</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">coursesToSelect.remove(cr1);<span class="comment">//删除指定某位置对象</span></span><br><span class="line"></span><br><span class="line">Course cr1 = (Course) coursesToSelect.get(<span class="number">0</span>);</span><br><span class="line">coursesToSelect.remove(cr1);<span class="comment">//删除指定对象，此时cr1获得的是引用，所以如果list中有两个执向相同地址的引用，不管get方法取自谁，都会先删除排序靠前的那个元素，当执行两次删除方法时，则删除掉两个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意</span></span><br><span class="line"><span class="comment">//Course cr1 = new Course("参数");</span></span><br><span class="line"><span class="comment">//coursesToSelect.remove(cr1);</span></span><br><span class="line"><span class="comment">//这样并不能删除指定对象，即便参数相同，但因为引用不同，指向内存不同，故无法删除</span></span><br><span class="line"></span><br><span class="line">Course[] courses = &#123; (Course) coursesToSelect.get(<span class="number">4</span>), (Course) coursesToSelect.get(<span class="number">5</span>) &#125;;</span><br><span class="line">coursesToSelect.removeAll(Arrays.asList(courses));<span class="comment">//批量删除，即使取出序号不相邻也可执行，其内部机制是将对象数组取出，分别执行删除单个对象</span></span><br></pre></td></tr></table></figure>
<h4 id="Modify"><a href="#Modify" class="headerlink" title="Modify"></a>Modify</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">coursesToSelect.set(<span class="number">4</span>, <span class="keyword">new</span> Course(<span class="string">"7"</span>, <span class="string">"毛概"</span>));<span class="comment">//修改指定位置元素</span></span><br></pre></td></tr></table></figure>
<h4 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 通过for循环取得List中的元素的方法</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@param</span> args</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = coursesToSelect.size();</span><br><span class="line">    System.out.println(<span class="string">"有如下课程待选："</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        Course cr = (Course) coursesToSelect.get(i);</span><br><span class="line">        System.out.println(<span class="string">"课程："</span> + cr.id + <span class="string">":"</span> + cr.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 通过迭代器Iterator来遍历List</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@param</span> args</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过集合的iterator方法，取得迭代器的实例</span></span><br><span class="line">    Iterator&lt;Course&gt; it = coursesToSelect.iterator();</span><br><span class="line">    System.out.println(<span class="string">"有如下课程待选(通过迭代器访问)："</span>);</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        Course cr = it.next();</span><br><span class="line">        System.out.println(<span class="string">"课程："</span> + cr.id + <span class="string">":"</span> + cr.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 通过for each方法访问集合元素</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@param</span> args</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testForEach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"有如下课程待选(通过for each访问)："</span>);</span><br><span class="line">    <span class="keyword">for</span> (Object obj : coursesToSelect) &#123;</span><br><span class="line">        Course cr = (Course) obj;</span><br><span class="line">        System.out.println(<span class="string">"课程："</span> + cr.id + <span class="string">":"</span> + cr.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><ul>
<li><p>Set与Collection最大的不同是其内部元素是无序且不可重复的，被称为集（这里的无序是指引用不同）</p>
</li>
<li><p>HashSet–哈希集，是Set的一个重要实现类，同ArrayList的地位一样，在创建对象时使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set courses = new HashSet();</span><br></pre></td></tr></table></figure>
</li>
<li><p>因为Set是无序的，所以没有get方法，也不能通过for循环get出遍历全部对象，自能通过foreach和iterator遍历出全部对象，并且每次遍历出的顺序都不一样。</p>
</li>
<li><p>Set中，添加某个对象，无论添加多少次， 最终只会保留一个该对象（的引用）， 并且，保留的是第一次添加的那一个</p>
</li>
<li><p>Set中还可以添加一个null元素，但也只能添加一个</p>
</li>
</ul>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><ul>
<li><p>Map提供了一种映射关系，其中的元素是以键值对（key-value）的形式存储的，能够实现根据key快速查找value</p>
</li>
<li><p>Map中的键值对以Entry类型的对象实例形式存在</p>
</li>
<li><p>键（key值）不可重复，value值可以</p>
</li>
<li><p>每个键最多只能映射到一个值</p>
</li>
<li><p>Map接口提供了分别返回key值集合，value值集合以及Entry（键值对）集合的方法</p>
</li>
<li><p>Map支持泛型，形式如：Map &lt; k，V &gt;</p>
</li>
</ul>
<h3 id="HashMap类"><a href="#HashMap类" class="headerlink" title="HashMap类"></a>HashMap类</h3><ul>
<li><p>HashMap是Map的一个重要实现类，也是最常用，基于哈希表实现</p>
</li>
<li><p>HashMap中的Entry对象是无序排列的</p>
</li>
<li><p>key值和value值都可以为null，但是一个HashMap只能有一个key值为null的映射（key值不可重复）</p>
</li>
</ul>
<h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><p>通过put方法就可以添加新的元素，已存在key则修改Value值，不存在则创建</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">students.put(ID, newStudent);</span><br></pre></td></tr></table></figure>
<h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><p>通过remove方法就可以指定key值的元素，当key值不存在时返回null</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">students.remove(ID);</span><br></pre></td></tr></table></figure>
<h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><p>put和replace都支持修改元素操作，replace是JDK8中新增加的方法，实现机制更简单。二者都会首先判断key值是否存在，不存在会返回null，存在则修改。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">students.put(ID，newValue);</span><br><span class="line">students.replace(k, v);</span><br></pre></td></tr></table></figure></p>
<h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><p>利用keySet遍历Map：keySet方法返回是key值的Set集，遍历此Set集然后通过key就可get到对应的value。通过get方法取出Value时，当存在key就返回对应Value，不存在则返回null。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; keySet = students.keySet();</span><br><span class="line">// 遍历keySet，取得每一个键，再调用get方法取得每个键对应的value</span><br><span class="line">for (String stuId : keySet) &#123;</span><br><span class="line">    Student st = students.get(stuId);</span><br><span class="line">    if (st != null)</span><br><span class="line">        System.out.println(&quot;学生：&quot; + st.name);</span><br><span class="line">        System.out.println(&quot;取得键：&quot; + stuId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用entrySet遍历Map：entrySet方法返回的是Entry键值对的对象，通过getkey和getvalue取出键值对的键和值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Entry&lt;String, Student&gt;&gt; entrySet = students.entrySet();</span><br><span class="line">for (Entry&lt;String, Student&gt; entry : entrySet) &#123;</span><br><span class="line">    System.out.println(&quot;取得键：&quot; + entry.getKey());</span><br><span class="line">    System.out.println(&quot;对应的值为：&quot; + entry.getValue().name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关于集合框架的其他知识点"><a href="#关于集合框架的其他知识点" class="headerlink" title="关于集合框架的其他知识点"></a>关于集合框架的其他知识点</h2><h3 id="Contains"><a href="#Contains" class="headerlink" title="Contains"></a>Contains</h3><h4 id="List中的contains"><a href="#List中的contains" class="headerlink" title="List中的contains"></a>List中的contains</h4><p>一些方法如contains，内部机制是首先遍历集合再对比object，相同返回true，不同返回false，这些方法都要用到equals，但equals默认对比的是两个对象，即使两个对象内容相同，如果内存不同还是会返回false，此时就要重写equals方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == obj)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//首先比较对象引用，引用相同返回true</span></span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//当对象是null时，则返回false</span></span><br><span class="line">    <span class="keyword">if</span> (!(obj <span class="keyword">instanceof</span> Course))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 当obj不是由Course或其子类创建的对象时返回false</span></span><br><span class="line">    Course other = (Course) obj;<span class="comment">//此时开始对比对象内容，先将Object类转为子类</span></span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123; </span><br><span class="line">        <span class="keyword">if</span> (other.name != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//当当前name为null，而对比对象name不为null，返回false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!name.equals(other.name))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//当当前对象不为null，对比对象name不等于当前对象name，返回false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//其他则返回true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此例可以作为重写equals的模板</p>
<h4 id="Set中的contains"><a href="#Set中的contains" class="headerlink" title="Set中的contains"></a>Set中的contains</h4><p>Map中的contains和List的不同是其要对比HashCode和equals两个方法，所以只比较内容应重写这两个方法。eclipse提供了自动重写HashCode和equals，在源码（Alt + Shift + S）中可以找到</p>
<p>hashCode的重写<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> prime = <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">    result = prime * result + ((name == <span class="keyword">null</span>) ? <span class="number">0</span> : name.hashCode());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Map中的contains"><a href="#Map中的contains" class="headerlink" title="Map中的contains"></a>Map中的contains</h4><p>Map中有containsKey和ContainsValue两个方法判断是否包含对应的key和value，也是遍历和equals，同Set一样需要重写HashCode和equals方法。</p>
<h3 id="indexOf和lastIndexOf"><a href="#indexOf和lastIndexOf" class="headerlink" title="indexOf和lastIndexOf"></a>indexOf和lastIndexOf</h3><p>indexOf和lastIndexOf的实现机制是首先遍历所有整个集合，当集合中的对象等于指定对象时返回序号，不包含则返回-1，当出现同样的元素时，index返回正序第一个，lastindex返回倒序第一个。</p>
<p>因为也要调用equals方法，所以当需要对比内容时也要重写equals。</p>
<h3 id="Collections-sort排序"><a href="#Collections-sort排序" class="headerlink" title="Collections.sort排序"></a>Collections.sort排序</h3><p>此方法可以对序列进行排序，数字按升序，字符串按先数字，再大写字母，再小写字母的顺序。</p>
<p>sort（）中传入的参数需要实现<strong> Comparable </strong>接口或一个list，一个Comparator（比较规则）</p>
<p>另外Collections还有其他的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Collections.shuffle();<span class="comment">//随机打乱顺序</span></span><br><span class="line">Collections.reverse();<span class="comment">//倒序排列</span></span><br></pre></td></tr></table></figure></p>
<p>Collections类操作集合时是对集合进行操作，并不会产生新的集合，不需要定义集合接收。</p>
<h4 id="Comparable接口–可比较的"><a href="#Comparable接口–可比较的" class="headerlink" title="Comparable接口–可比较的"></a>Comparable接口–可比较的</h4><ol>
<li><p>实现该接口表示：这个实例可以比较大小，可以进行自然排序</p>
</li>
<li><p>定义了默认的比较规则</p>
</li>
<li><p>其实现类需实现comparaTo()方法</p>
</li>
<li><p>comparaTo()方法返回正数表示大，负数表示小，0表示相等</p>
</li>
</ol>
<p>具体使用方法：</p>
<p>首先要领List中的对象实现Comparable接口，Comparable接口中有compareTo方法定义比较规则</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Student</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//Comparable接口也支持泛型</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.id.compareTo(o.id);<span class="comment">//规则是比较Student的id</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Comparator接口–比较工具接口"><a href="#Comparator接口–比较工具接口" class="headerlink" title="Comparator接口–比较工具接口"></a>Comparator接口–比较工具接口</h4><ol>
<li><p>用于定义临时比较规则，而不是默认比较规则</p>
</li>
<li><p>其实现类需要实现conpara()方法</p>
</li>
<li><p>Comparator和Comparable都是Java集合框架的成员</p>
</li>
</ol>
<p>使用Comparator时不需要实现Comparable接口，而是要定义一个新的类实现Comparator接口定义比较规则</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Student</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student o1, Student o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.name.compareTo(o2.name);<span class="comment">//规则是比较Student的name</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用时要在sort中传入list和比较规则两个参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(studentList, new StudentComparator());</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1><hr>

      
    </div>
    
    <div>
      
        
      
    </div>

    <div>
      
        
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Android/" rel="tag">#Android</a>
          
            <a href="/tags/Java/" rel="tag">#Java</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/04/18/winXP-in-VM/" rel="next" title="VMware+Windows XP的安装">
                <i class="fa fa-chevron-left"></i> VMware+Windows XP的安装
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/09/16/Genymotion-Repair/" rel="prev" title="Genymotion终于复活了">
                Genymotion终于复活了 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <div class="ds-share flat" data-thread-key="2016/09/03/imooc-java-vedio-note/"
     data-title="再看Java--imooc三季Java视频笔记"
     data-content=""
     data-url="http://yoursite.com/2016/09/03/imooc-java-vedio-note/">
  <div class="ds-share-inline">
    <ul  class="ds-share-icons-16">

      <li data-toggle="ds-share-icons-more"><a class="ds-more" href="javascript:void(0);">分享到：</a></li>
      <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
      <li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li>
      <li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li>
      <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>

    </ul>
    <div class="ds-share-icons-more">
    </div>
  </div>
</div>
      
    </div>
  </div>


          </div>
          

  <p>热评文章</p>
  <div class="ds-top-threads" data-range="weekly" data-num-items="4"></div>


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/09/03/imooc-java-vedio-note/"
           data-title="再看Java--imooc三季Java视频笔记" data-url="http://yoursite.com/2016/09/03/imooc-java-vedio-note/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="小牛" />
          <p class="site-author-name" itemprop="name">小牛</p>
          <p class="site-description motion-element" itemprop="description">人的一切痛苦，本质上都是对自己无能的愤怒</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/">
              <span class="site-state-item-count">6</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="http://niujiajun.com/wechat.html" target="_blank">
                  
                    <i class="fa fa-globe"></i>
                  
                  wechat
                </a>
              </span>
            
          
        </div>

        
        

        
        <div class="links-of-blogroll motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#基础"><span class="nav-number">1.</span> <span class="nav-text">基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#发展历史"><span class="nav-number">1.1.</span> <span class="nav-text">发展历史</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK环境变量配置"><span class="nav-number">1.2.</span> <span class="nav-text">JDK环境变量配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java中的注释"><span class="nav-number">1.3.</span> <span class="nav-text">Java中的注释</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#文档注释：以-开始，以-结束"><span class="nav-number">1.3.1.</span> <span class="nav-text">文档注释：以/*开始，以/结束</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#输出"><span class="nav-number">1.4.</span> <span class="nav-text">输出</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#输入"><span class="nav-number">1.5.</span> <span class="nav-text">输入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#javadoc生成文档"><span class="nav-number">1.6.</span> <span class="nav-text">javadoc生成文档</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#运算符"><span class="nav-number">2.</span> <span class="nav-text">运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#算术运算符-，–"><span class="nav-number">2.1.</span> <span class="nav-text">算术运算符++，–</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#左边"><span class="nav-number">2.1.1.</span> <span class="nav-text">左边</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#右边"><span class="nav-number">2.1.2.</span> <span class="nav-text">右边</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#赋值运算符"><span class="nav-number">2.2.</span> <span class="nav-text">赋值运算符</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#关于switch"><span class="nav-number">3.</span> <span class="nav-text">关于switch</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数组"><span class="nav-number">4.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#声明数组"><span class="nav-number">4.1.</span> <span class="nav-text">声明数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分配空间"><span class="nav-number">4.2.</span> <span class="nav-text">分配空间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#初始化"><span class="nav-number">4.3.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#操作"><span class="nav-number">4.4.</span> <span class="nav-text">操作</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Class类"><span class="nav-number">5.</span> <span class="nav-text">Class类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#重载"><span class="nav-number">6.</span> <span class="nav-text">重载</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#成员变量和局部变量的区别"><span class="nav-number">6.1.</span> <span class="nav-text">成员变量和局部变量的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#构造方法"><span class="nav-number">6.2.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#static"><span class="nav-number">6.3.</span> <span class="nav-text">static</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#封装"><span class="nav-number">6.4.</span> <span class="nav-text">封装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#访问修饰符"><span class="nav-number">6.5.</span> <span class="nav-text">访问修饰符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内部类"><span class="nav-number">6.6.</span> <span class="nav-text">内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#成员内部类"><span class="nav-number">6.6.1.</span> <span class="nav-text">成员内部类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#静态内部类"><span class="nav-number">6.6.2.</span> <span class="nav-text">静态内部类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法内部类"><span class="nav-number">6.7.</span> <span class="nav-text">方法内部类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#继承"><span class="nav-number">7.</span> <span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#继承的初始化顺序"><span class="nav-number">7.1.</span> <span class="nav-text">继承的初始化顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重写-override"><span class="nav-number">7.2.</span> <span class="nav-text">重写@override</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#final"><span class="nav-number">7.3.</span> <span class="nav-text">final</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#super"><span class="nav-number">7.4.</span> <span class="nav-text">super</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Object类"><span class="nav-number">7.5.</span> <span class="nav-text">Object类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#多态"><span class="nav-number">8.</span> <span class="nav-text">多态</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#java中的多态"><span class="nav-number">8.1.</span> <span class="nav-text">java中的多态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多态中的引用类型转换"><span class="nav-number">8.2.</span> <span class="nav-text">多态中的引用类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#instanceof"><span class="nav-number">8.2.1.</span> <span class="nav-text">instanceof</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#抽象类abstract"><span class="nav-number">8.3.</span> <span class="nav-text">抽象类abstract</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义"><span class="nav-number">8.3.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#应用场景"><span class="nav-number">8.3.2.</span> <span class="nav-text">应用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#作用"><span class="nav-number">8.3.3.</span> <span class="nav-text">作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用规则"><span class="nav-number">8.3.4.</span> <span class="nav-text">使用规则</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#接口"><span class="nav-number">9.</span> <span class="nav-text">接口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概念"><span class="nav-number">9.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#定义-1"><span class="nav-number">9.2.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用"><span class="nav-number">9.3.</span> <span class="nav-text">使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#abstract类与接口的比较"><span class="nav-number">9.4.</span> <span class="nav-text">abstract类与接口的比较</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#匿名内部类"><span class="nav-number">10.</span> <span class="nav-text">匿名内部类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#异常类"><span class="nav-number">11.</span> <span class="nav-text">异常类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#try-catch语句"><span class="nav-number">11.1.</span> <span class="nav-text">try-catch语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#finally子语句"><span class="nav-number">11.2.</span> <span class="nav-text">finally子语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#异常抛出"><span class="nav-number">11.3.</span> <span class="nav-text">异常抛出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#throw"><span class="nav-number">11.3.1.</span> <span class="nav-text">throw</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#throws"><span class="nav-number">11.3.2.</span> <span class="nav-text">throws</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义异常"><span class="nav-number">11.3.3.</span> <span class="nav-text">自定义异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异常链"><span class="nav-number">11.3.4.</span> <span class="nav-text">异常链</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#String"><span class="nav-number">12.</span> <span class="nav-text">String</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串的不变性"><span class="nav-number">12.1.</span> <span class="nav-text">字符串的不变性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String类常用方法"><span class="nav-number">12.2.</span> <span class="nav-text">String类常用方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#StringBuilder和StringBuffer"><span class="nav-number">12.3.</span> <span class="nav-text">StringBuilder和StringBuffer</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java中的包装类"><span class="nav-number">13.</span> <span class="nav-text">Java中的包装类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#以Interger举例"><span class="nav-number">13.1.</span> <span class="nav-text">以Interger举例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基本类型和包装类之间的互相转换（以-Integer-为例）"><span class="nav-number">13.2.</span> <span class="nav-text">基本类型和包装类之间的互相转换（以 Integer 为例）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-中基本类型和字符串之间的转换（以-Integer-为例）"><span class="nav-number">13.3.</span> <span class="nav-text">Java 中基本类型和字符串之间的转换（以 Integer 为例）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#常用类"><span class="nav-number">14.</span> <span class="nav-text">常用类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#使用-Date-和-SimpleDateFormat-类表示时间"><span class="nav-number">14.1.</span> <span class="nav-text">使用 Date 和 SimpleDateFormat 类表示时间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Calendar-类的应用"><span class="nav-number">14.2.</span> <span class="nav-text">Calendar 类的应用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用-Math-类操作数据"><span class="nav-number">14.3.</span> <span class="nav-text">使用 Math 类操作数据</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java集合框架"><span class="nav-number">15.</span> <span class="nav-text">Java集合框架</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#作用-1"><span class="nav-number">15.1.</span> <span class="nav-text">作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#与数组的对比–为何选择集合而不是数组"><span class="nav-number">15.2.</span> <span class="nav-text">与数组的对比–为何选择集合而不是数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集合框架"><span class="nav-number">15.3.</span> <span class="nav-text">集合框架</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#泛型"><span class="nav-number">15.4.</span> <span class="nav-text">泛型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Collection"><span class="nav-number">15.5.</span> <span class="nav-text">Collection</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#List"><span class="nav-number">15.5.1.</span> <span class="nav-text">List</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Add"><span class="nav-number">15.5.1.1.</span> <span class="nav-text">Add</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Remove"><span class="nav-number">15.5.1.2.</span> <span class="nav-text">Remove</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Modify"><span class="nav-number">15.5.1.3.</span> <span class="nav-text">Modify</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Get"><span class="nav-number">15.5.1.4.</span> <span class="nav-text">Get</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Set"><span class="nav-number">15.5.2.</span> <span class="nav-text">Set</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Map"><span class="nav-number">15.6.</span> <span class="nav-text">Map</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap类"><span class="nav-number">15.6.1.</span> <span class="nav-text">HashMap类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#增"><span class="nav-number">15.6.2.</span> <span class="nav-text">增</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删"><span class="nav-number">15.6.3.</span> <span class="nav-text">删</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#改"><span class="nav-number">15.6.4.</span> <span class="nav-text">改</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查"><span class="nav-number">15.6.5.</span> <span class="nav-text">查</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于集合框架的其他知识点"><span class="nav-number">15.7.</span> <span class="nav-text">关于集合框架的其他知识点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Contains"><span class="nav-number">15.7.1.</span> <span class="nav-text">Contains</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#List中的contains"><span class="nav-number">15.7.1.1.</span> <span class="nav-text">List中的contains</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Set中的contains"><span class="nav-number">15.7.1.2.</span> <span class="nav-text">Set中的contains</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Map中的contains"><span class="nav-number">15.7.1.3.</span> <span class="nav-text">Map中的contains</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#indexOf和lastIndexOf"><span class="nav-number">15.7.2.</span> <span class="nav-text">indexOf和lastIndexOf</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Collections-sort排序"><span class="nav-number">15.7.3.</span> <span class="nav-text">Collections.sort排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Comparable接口–可比较的"><span class="nav-number">15.7.3.1.</span> <span class="nav-text">Comparable接口–可比较的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Comparator接口–比较工具接口"><span class="nav-number">15.7.3.2.</span> <span class="nav-text">Comparator接口–比较工具接口</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#END"><span class="nav-number">16.</span> <span class="nav-text">END</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">小牛</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



<script>
(function(){
    var bp = document.createElement('script');
    bp.src = '//push.zhanzhang.baidu.com/push.js';
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"xiaoniu-notes"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
      
      <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
      <script src="/js/src/hook-duoshuo.js"></script>
    
  





  
  
  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("rk1g6SMHjihkc91LeztBMEds-gzGzoHsz", "Jo2C9gz7OeLrBDlGK1IwlU7U");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

</body>
</html>
